TCP 三次握手和四次挥手

### 三次握手：

TCP是面向连接的服务，所以必须要先建立连接才能传输数据，最后在结束连接。

连接过程：

1. 客户端先发送一个同步报文，即SYN项置1的报文，然后拟定一个序列号$x$,即$seq=x$,数据部分不携带任何字节发送给服务器。
2. 服务器接收到同步报文后，要回复一个确认报文和同步报文（至于为什么会回复一个同步报文不清楚）。确认报文首先得ACK置1，然后确认号为$x+1$,即$ack= x+1$,（注意，小写的ack和大写的ACK不一样），因为确认报文的序列号代表的是希望收到发送方下一个字节的序号，因为之前发送方的报文并不携带数据信息，所以服务端希望得到的应该还是第$x$字节数据，但是TCP规定SYN报文不携带数据也要消耗掉一个序号，所以假定同步报文携带了一个数据字节。这同时还是一个同步报文，所以SYN项置1，并且设置序列号为$y$,将其发送给客户端。总结一下，就是ACK置1，SYN置1，$ack = x+ 1,seq = y$.
3. 同理，客户端此时也要发送一个确认报文给服务器端，ACK置1，$ack = y+1$, 序列号是$seq = x+1$。（在这里客户端TCP协议一个数据字段都没有发送，但是序列号相比于第一步的$x$增加了1，因为同步报文默认占一个字节）

至于为什么要三次握手，而不是二次握手，就是在第二步服务器端发送完确认报文就结束？

是为了防止已经超时的客户端请求重新让服务器端开始一次TCP连接。详细过程为，假设客户端发送一个TCP同步请求，在网络中超时到达了服务端。然而在此过程种，客户端重新开起了一次TCP请求，并且和接收端完成了握手工作。当之前的TCP同步请求到达服务器端的时候，服务器端不清楚是之前发送的请求，于是当成了新的请求对待，也发送了一个确认报文给客户端。此时如果是二次握手，即没有客户端发送给确认报文给服务器端的情况下，这时客户端和服务器端共同开启了一个无用的连接，对于客户端没有影响，会在第二次握手时候将确认报文丢失，但是服务器端就被占用了一些资源。如果此过程是三次握手，那么服务器端只有在第三次接收到确认报文的时候才开辟资源，但是这个过程永远不会实现，因为第二次握手过程中，客户端已经将收到的确认同步报文丢弃掉了。

